---
layout: post
title: "Monoids"
tags: [monoids]
description: "Describes Monoids in F#"
keywords: f#, fsharp, functional, programming, monoids
---

<p>A monoid is a simple concept. It is a generalization of some patterns that you
very likely already have seen. Being aware of those can help in designing some
operations, and can simplify things. Without much further ado, let us look at
three simple math equations.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
</pre></td>
<td class="snippet"><pre class="fssnip"><code lang="math">1 + 2       = 3
(1 + 2) + 3 = 1 + (2 + 3)
1 + 0       = 0 + 1
</code></pre></td></tr></table>
<h2>Table of Content</h2>
<ul class="toc">
  <li><a href="#binary">Binary Operations</a></li>
  <li><a href="#assoc">Associativity</a></li>
  <li><a href="#identity">Identity</a></li>
  <li><a href="#monoids">Monoids</a></li>
    <ul>
      <li><a href="#example-sub">Subtraction</a></li>
      <li><a href="#example-mul">Multiplication</a></li>
      <li><a href="#example-div">Division</a></li>
    </ul>
  <li><a href="#purpose">What is the purpose of all of this?</a></li>
    <ul>
      <li><a href="#pur-bin">Binary Operations</a></li>
      <li><a href="#pur-assoc">Associativity</a></li>
      <li><a href="#pur-identity">Identity</a></li>
    </ul>
  <li><a href="#mono">Monoids Examples</a></li>
    <ul>
      <li><a href="#mono-str-concat">String concatenation</a></li>
      <li><a href="#mono-list-appending">List appending</a></li>
      <li><a href="#mono-max-value">Maximum value</a></li>
      <li><a href="#mono-sets">Combining Sets</a></li>
    </ul>
  <li><a href="#comm-monoids">Commutative Monoids</a></li>
  <li><a href="#type">Creating Monoids Types</a></li>
    <ul>
      <li><a href="#type-sum">Sum Monoid</a></li>
      <li><a href="#type-product">Product Monoid</a></li>
      <li><a href="#type-ordering">Ordering Monoid</a></li>
    </ul>
  <li><a href="#summary">Summary</a></li>
  <li><a href="#further">Further Reading</a></li>
  <li><a href="#comments">Comments</a></li>
</ul>
<a name="binary"></a>
<h2>Binary Operations</h2>
<p>When we look at the first equation we just see the following: There exists some kind
of binary operation that takes two things of the same type, and somehow <em>combines</em>
those two things into one result of the same type. When we look at the type-signature
of our <code>+</code> operation we see something like</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip"><code lang="no">int -&gt; int -&gt; int
</code></pre></td></tr></table>
<p>or when we generalize the idea, we expect any type. So we think of functions with
the signature</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip"><code lang="no">'a -&gt; 'a -&gt; 'a
</code></pre></td></tr></table>
<a name="assoc"></a>
<h2>Associativity</h2>
<p>The second equation tells us that our binary operation <code>+</code> has another property. The
order in which we do the calculation don't change the end result. We can first
calculate <code>1 + 2</code> and then add <code>3</code> or we can first calculate <code>2 + 3</code> and then
add <code>1</code>. Both result in <code>6</code>.</p>
<a name="identity"></a>
<h2>Identity</h2>
<p>The last equation tells us that there exists some kind of <em>zero-element</em> or in mathematics
named <em>identity</em> that don't effect the result of the operation. It works as some
kind of <em>noop-operation</em>.</p>
<p>For the binary operation <code>+</code> this kind of element is <code>0</code>. No matter which number we have,
when we add zero to it, it doesn't change the number at all.</p>
<a name="monoids"></a>
<h2>Monoids</h2>
<p>Whenever all three properties are fulfilled, we name it a monoid. The question is probably
how such kind of simple generalization is even helpful. But before we look into this, let's
look at some other example first, to get a better hang of the three rules. First all three rules again.</p>
<ol>
<li>There exists a binary operation that combines two things, and returns something of the same type.</li>
<li>The binary operation is associative.</li>
<li>There is some kind of <em>Zero/Identity/Noop-element</em> for the binary operation.</li>
</ol>
<p>To understand the rules better let's look at <code>-</code>, <code>*</code> and <code>/</code>. As all of those are binary
operations all of them already fulfil the first rule, but do they also fulfil the
second and third rule?</p>
<a name="example-sub"></a>
<h3>Subtraction</h3>
<p>Subtraction is not associative. <code>(1 - 2) - 3</code> gives us <code>-1 - 3</code> that result in <code>-4</code>. But
<code>1 - (2 - 3)</code> gives us <code>1 - (-1)</code> and this returns <code>2</code>.</p>
<p>There also does not exists an identity element. We could think once again of <code>0</code>. As <code>1 - 0</code>
return once again <code>1</code> unchanged. But when we do <code>0 - 1</code> we get <code>-1</code>.</p>
<a name="example-mul"></a>
<h3>Multiplication</h3>
<p>Multiplication is a monoid as both rules are fulfilled. We can do multiplication in any order
and it always yield the same result. But what is our identity element? This time it is <code>1</code>
not <code>0</code>. Multiplying a number with <code>1</code> never changes the number itself.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
</pre></td>
<td class="snippet"><pre class="fssnip"><code lang="math">(1 * 2) * 3 = 6
1 * (2 * 3) = 6
6 * 1 = 6
1 * 6 = 6
</code></pre></td></tr></table>
<a name="example-div"></a>
<h3>Division</h3>
<p>Division is not associative:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
</pre></td>
<td class="snippet"><pre class="fssnip"><code lang="math">(100.0 / 2.0) / 5.0 =  50.0 / 5.0 = 10.0
100.0 / (2.0 / 5.0) = 100.0 / 0.4 = 250.0
</code></pre></td></tr></table>
<p>and we also don't have an identity element. We could once again think of <code>1</code>. As <code>3.0 / 1.0</code>
don't change <code>3.0</code>, but the reverse <code>1.0 / 3.0</code> is once again something different.</p>
<a name="purpose"></a>
<h2>What is the purpose of all of this?</h2>
<p>Now that we have seen more examples we should get familiar with the concept. But why are those
rules anyway useful? Actually, all three rules gives us an ability that we can use in programming.</p>
<a name="pur-bin"></a>
<h3>Binary Operations</h3>
<p>When we have a binary operation that combines two things that returns another new thing of the same
type. It simply means we always can combine a whole list of elements with <code>List.reduce</code>. Let's
assume we have a list of numbers and we just want to add, subtract, multiply or divide all numbers.
Then we just can write:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs6', 6)" onmouseover="showTip(event, 'fs6', 6)" class="i">xs</span> <span class="o">=</span> [<span class="n">1.0</span> <span class="o">..</span> <span class="n">10.0</span>]

<span onmouseout="hideTip(event, 'fs7', 7)" onmouseover="showTip(event, 'fs7', 7)" class="t">List</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs8', 8)" onmouseover="showTip(event, 'fs8', 8)" class="f">reduce</span> (<span class="o">+</span>) <span onmouseout="hideTip(event, 'fs6', 9)" onmouseover="showTip(event, 'fs6', 9)" class="i">xs</span> <span class="c">// 55.0</span>
<span onmouseout="hideTip(event, 'fs7', 10)" onmouseover="showTip(event, 'fs7', 10)" class="t">List</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs8', 11)" onmouseover="showTip(event, 'fs8', 11)" class="f">reduce</span> (<span class="o">-</span>) <span onmouseout="hideTip(event, 'fs6', 12)" onmouseover="showTip(event, 'fs6', 12)" class="i">xs</span> <span class="c">// -53.0</span>
<span onmouseout="hideTip(event, 'fs7', 13)" onmouseover="showTip(event, 'fs7', 13)" class="t">List</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs8', 14)" onmouseover="showTip(event, 'fs8', 14)" class="f">reduce</span> <span class="o">(*)</span> <span onmouseout="hideTip(event, 'fs6', 15)" onmouseover="showTip(event, 'fs6', 15)" class="i">xs</span> <span class="c">// 3628800.0</span>
<span onmouseout="hideTip(event, 'fs7', 16)" onmouseover="showTip(event, 'fs7', 16)" class="t">List</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs8', 17)" onmouseover="showTip(event, 'fs8', 17)" class="f">reduce</span> (<span class="o">/</span>) <span onmouseout="hideTip(event, 'fs6', 18)" onmouseover="showTip(event, 'fs6', 18)" class="i">xs</span> <span class="c">// 2.755731922e-07</span>
</code></pre></td>
</tr>
</table>
<p>If you are unfamiliar with <code>List.reduce</code>. You can think of it as a way to always combines the first two
elements of a list, until you only have a single element left. When we use <code>List.reduce</code> on</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp">[<span class="n">1</span>;<span class="n">2</span>;<span class="n">3</span>;<span class="n">4</span>;<span class="n">5</span>]
</code></pre></td>
</tr>
</table>
<p>it basically combines the first two elements. <code>1 + 2</code> and replaces it with <code>3</code>. So what happens is
just:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp">[<span class="n">1</span>;<span class="n">2</span>;<span class="n">3</span>;<span class="n">4</span>;<span class="n">5</span>]
[<span class="n">3</span>;<span class="n">3</span>;<span class="n">4</span>;<span class="n">5</span>]
[<span class="n">6</span>;<span class="n">4</span>;<span class="n">5</span>]
[<span class="n">10</span>;<span class="n">5</span>]
[<span class="n">15</span>]
</code></pre></td>
</tr>
</table>
<p>Once there is only a single result, it returns it.</p>
<div class="info">
This is not how it exactly works, but this is one way how you can think of it.
</div>
<p>But think about it why it makes in general sense that we can reduce a list of something to
a single value. When we can combine two things into one thing, we always can keep
going combining two things until we end up with a single element. A <code>reduce</code> operation
just does that repetitive combining for us.</p>
<a name="pur-assoc"></a>
<h3>Associativity</h3>
<p>Associativity can enhance the reduce operation. If the exact order doesn't play a role. It means
the combining can be done in Parallel on multiple CPUs. As a simple example let's look at a list
with four elements.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp">[<span class="n">1</span>;<span class="n">2</span>;<span class="n">3</span>;<span class="n">4</span>]
</code></pre></td>
</tr>
</table>
<p>CPU1 could start combining <code>1 + 2</code> while CPU2 starts combining <code>3 + 4</code>. Once both are finished
CPU1 could combine the result <code>3 + 7</code>.</p>
<p>But note that this is a naive approach, when we just combine numbers and always split every addition
on it's own CPU the whole combining process would be probably slower and not faster as before. To
be more efficient we need to better divide the input. For example combine the first 1000 elements
of a list on CPU1, and the elements 1001-2000 on CPU2 and so on. To get a fast operation it is a
little bit more complicated. But there usually already exists libraries that addresses those
problems. We could for example use <a href="http://fsprojects.github.io/FSharp.Collections.ParallelSeq/">FSharp.Collections.ParallelSeq</a></p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
<span class="l">11: </span>
<span class="l">12: </span>
<span class="l">13: </span>
<span class="l">14: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="c">// Sequence of all number from 1 to 10.000.000</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs9', 19)" onmouseover="showTip(event, 'fs9', 19)" class="i">nums</span> <span class="o">=</span> [| <span class="n">1L</span> <span class="o">..</span> <span class="n">10000000L</span> |]

<span class="c">// Reduce just with one CPU</span>
<span onmouseout="hideTip(event, 'fs10', 20)" onmouseover="showTip(event, 'fs10', 20)" class="t">Seq</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs11', 21)" onmouseover="showTip(event, 'fs11', 21)" class="f">reduce</span> (<span class="o">+</span>) <span onmouseout="hideTip(event, 'fs9', 22)" onmouseover="showTip(event, 'fs9', 22)" class="i">nums</span>

<span class="c">//Real: 00:00:00.103, CPU: 00:00:00.093, GC gen0: 0, gen1: 0, gen2: 0</span>
<span class="c">//val it : int64 = 50000005000000L</span>

<span class="c">// Reduce with multiple CPUs</span>
<span onmouseout="hideTip(event, 'fs12', 23)" onmouseover="showTip(event, 'fs12', 23)" class="t">PSeq</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs13', 24)" onmouseover="showTip(event, 'fs13', 24)" class="f">reduce</span> (<span class="o">+</span>) <span onmouseout="hideTip(event, 'fs9', 25)" onmouseover="showTip(event, 'fs9', 25)" class="i">nums</span>

<span class="c">//Real: 00:00:00.107, CPU: 00:00:00.390, GC gen0: 0, gen1: 0, gen2: 0</span>
<span class="c">//val it : int64 = 50000005000000L</span>
</code></pre></td>
</tr>
</table>
<p>And as you see, even then you have no guarantee that it is faster (I use a quad-core machine).
The problem is that the combine operation itself is already fast, or probably the reduce algorithm
in <code>PSeq</code> is not good enough. But still general speaking. Associativity opens up Parallelism, in the
case of using multiple CPUs or using multiple computers (distributed computing).</p>
<p>But it also allows you to divide an operations into chunks so you can save intermediate result
or calculate a result incrementally. In a reporting system you could for example aggregate all
data for one day, and save the result. If you want to create a month report, you always just
need to combine the results of let's say the last 30 days. You don't need to rerun the combine
operation completely from the start.</p>
<a name="pur-identity"></a>
<h3>Identity</h3>
<p>There is one problem with <code>reduce</code> or in general we have one problem. Our binary operations
always expect to combine two things. But what happens if we have zero or only one element? You
probably ask why we then even want to run a <code>reduce</code> operation. But in normal circumstances
we don't want to check the amount of elements in a list. But this leads to a problem.</p>
<p>A <code>reduce</code> operation with a single element just returns the single element, as there is nothing
to combine. But with an empty list it just throws an exception as it don't know what
it should return.</p>
<p>In such a case, the identity element is helpful, as we just can return the identity element.
But it is also useful in other cases. We just have some kind of starting value that we can
begin with. To solve the problem with <code>reduce</code> we can use <code>fold</code> instead of <code>reduce</code>.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs7', 26)" onmouseover="showTip(event, 'fs7', 26)" class="t">List</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs14', 27)" onmouseover="showTip(event, 'fs14', 27)" class="f">fold</span> (<span class="o">+</span>) <span class="n">0</span> []          <span class="c">// 0</span>
<span onmouseout="hideTip(event, 'fs7', 28)" onmouseover="showTip(event, 'fs7', 28)" class="t">List</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs14', 29)" onmouseover="showTip(event, 'fs14', 29)" class="f">fold</span> (<span class="o">+</span>) <span class="n">0</span> [<span class="n">1</span>;<span class="n">2</span>;<span class="n">3</span>;<span class="n">4</span>;<span class="n">5</span>] <span class="c">// 15</span>
<span onmouseout="hideTip(event, 'fs7', 30)" onmouseover="showTip(event, 'fs7', 30)" class="t">List</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs14', 31)" onmouseover="showTip(event, 'fs14', 31)" class="f">fold</span> <span class="o">(*)</span> <span class="n">1</span> []          <span class="c">// 1</span>
<span onmouseout="hideTip(event, 'fs7', 32)" onmouseover="showTip(event, 'fs7', 32)" class="t">List</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs14', 33)" onmouseover="showTip(event, 'fs14', 33)" class="f">fold</span> <span class="o">(*)</span> <span class="n">1</span> [<span class="n">1</span>;<span class="n">2</span>;<span class="n">3</span>;<span class="n">4</span>;<span class="n">5</span>] <span class="c">// 120</span>
</code></pre></td>
</tr>
</table>
<p>The additional value we pass to <code>fold</code> acts in this case as the identity element.</p>
<a name="mono"></a>
<h2>Monoids examples</h2>
<p>As we now have a rough view what an monoid is, and what it allows us to do, let's look at some
more simple monoids.</p>
<a name="mono-str-concat"></a>
<h3>String concatenation</h3>
<p>String concatenation is a monoid, the identity element is just the empty string.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs7', 34)" onmouseover="showTip(event, 'fs7', 34)" class="t">List</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs14', 35)" onmouseover="showTip(event, 'fs14', 35)" class="f">fold</span> (<span class="o">+</span>) <span class="s">&quot;&quot;</span> [<span class="s">&quot;Hello&quot;</span>; <span class="s">&quot; &quot;</span>; <span class="s">&quot;World!&quot;</span>] <span class="c">// &quot;Hello World!&quot;</span>
</code></pre></td>
</tr>
</table>
<a name="mono-list-appending"></a>
<h3>List appending</h3>
<p>Appending lists is a monoid. The identity element is just the empty list.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs7', 36)" onmouseover="showTip(event, 'fs7', 36)" class="t">List</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs14', 37)" onmouseover="showTip(event, 'fs14', 37)" class="f">fold</span> <span onmouseout="hideTip(event, 'fs7', 38)" onmouseover="showTip(event, 'fs7', 38)" class="t">List</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs15', 39)" onmouseover="showTip(event, 'fs15', 39)" class="f">append</span> [] [[<span class="s">&quot;foo&quot;</span>]; [<span class="s">&quot;bar&quot;</span>; <span class="s">&quot;baz&quot;</span>]]   <span class="c">// [&quot;foo&quot;; &quot;bar&quot;; &quot;baz&quot;]</span>
<span onmouseout="hideTip(event, 'fs7', 40)" onmouseover="showTip(event, 'fs7', 40)" class="t">List</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs14', 41)" onmouseover="showTip(event, 'fs14', 41)" class="f">fold</span> <span onmouseout="hideTip(event, 'fs7', 42)" onmouseover="showTip(event, 'fs7', 42)" class="t">List</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs15', 43)" onmouseover="showTip(event, 'fs15', 43)" class="f">append</span> [] [[<span class="n">1</span>;<span class="n">2</span>;<span class="n">3</span>]; [<span class="n">4</span>;<span class="n">5</span>;<span class="n">6</span>]; [<span class="n">7</span>;<span class="n">8</span>;<span class="n">9</span>]] <span class="c">// [1;2;3;4;5;6;7;8;9]</span>
</code></pre></td>
</tr>
</table>
<a name="mono-max-value"></a>
<h3>Maximum value</h3>
<p>We can threat the <code>max</code> operation as a monoid. It just takes two values, and returns
the one which is greater. Notice that combining doesn't literally mean we really have
to work with both values and <em>combine</em> them. A function that just throws away one
value is still valid.</p>
<p>If you wonder why. The only thing we must ensure is that we can combine two things into
one result. There is no restriction on the result itself. It only matters that we
get the same result.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp">(<span onmouseout="hideTip(event, 'fs16', 44)" onmouseover="showTip(event, 'fs16', 44)" class="f">max</span> (<span onmouseout="hideTip(event, 'fs16', 45)" onmouseover="showTip(event, 'fs16', 45)" class="f">max</span> <span class="n">1</span> <span class="n">2</span>) <span class="n">3</span>) <span class="c">// 3</span>
(<span onmouseout="hideTip(event, 'fs16', 46)" onmouseover="showTip(event, 'fs16', 46)" class="f">max</span> <span class="n">1</span> (<span onmouseout="hideTip(event, 'fs16', 47)" onmouseover="showTip(event, 'fs16', 47)" class="f">max</span> <span class="n">2</span> <span class="n">3</span>)) <span class="c">// 3</span>
</code></pre></td>
</tr>
</table>
<p>or with reduce.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs7', 48)" onmouseover="showTip(event, 'fs7', 48)" class="t">List</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs8', 49)" onmouseover="showTip(event, 'fs8', 49)" class="f">reduce</span> <span onmouseout="hideTip(event, 'fs16', 50)" onmouseover="showTip(event, 'fs16', 50)" class="f">max</span> [<span class="n">1</span>;<span class="n">2</span>;<span class="n">3</span>;<span class="n">4</span>;<span class="n">5</span>;<span class="n">6</span>]         <span class="c">// 6</span>
<span onmouseout="hideTip(event, 'fs7', 51)" onmouseover="showTip(event, 'fs7', 51)" class="t">List</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs8', 52)" onmouseover="showTip(event, 'fs8', 52)" class="f">reduce</span> <span onmouseout="hideTip(event, 'fs16', 53)" onmouseover="showTip(event, 'fs16', 53)" class="f">max</span> [<span class="s">&quot;foo&quot;</span>; <span class="s">&quot;abc&quot;</span>; <span class="s">&quot;zoo&quot;</span>] <span class="c">// &quot;zoo&quot;</span>
</code></pre></td>
</tr>
</table>
<p>But what is the identity element? Well it depends on the type we use. Just consider what
the purpose of the identity element is. It acts as a noop-operation. When we have one value
and use it with the identity element, we always must get the input value back.</p>
<p>When we use <code>max</code> with <code>int</code>, we must find an <code>int</code> that always makes sure we get our input
value unchanged back, no matter what our input is. That means the identity element
for <code>max</code> with the <code>int</code> type is <code>Int32.MinValue</code></p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs16', 54)" onmouseover="showTip(event, 'fs16', 54)" class="f">max</span> <span onmouseout="hideTip(event, 'fs17', 55)" onmouseover="showTip(event, 'fs17', 55)" class="t">Int32</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs18', 56)" onmouseover="showTip(event, 'fs18', 56)" class="i">MinValue</span> <span class="o">-</span><span class="n">2147483648</span>    <span class="c">// -2147483648</span>
<span onmouseout="hideTip(event, 'fs16', 57)" onmouseover="showTip(event, 'fs16', 57)" class="f">max</span> <span onmouseout="hideTip(event, 'fs17', 58)" onmouseover="showTip(event, 'fs17', 58)" class="t">Int32</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs18', 59)" onmouseover="showTip(event, 'fs18', 59)" class="i">MinValue</span> <span class="n">0</span>              <span class="c">// 0</span>
<span onmouseout="hideTip(event, 'fs16', 60)" onmouseover="showTip(event, 'fs16', 60)" class="f">max</span> <span onmouseout="hideTip(event, 'fs17', 61)" onmouseover="showTip(event, 'fs17', 61)" class="t">Int32</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs18', 62)" onmouseover="showTip(event, 'fs18', 62)" class="i">MinValue</span> <span class="n">12345</span>          <span class="c">// 12345</span>
<span onmouseout="hideTip(event, 'fs16', 63)" onmouseover="showTip(event, 'fs16', 63)" class="f">max</span> <span onmouseout="hideTip(event, 'fs17', 64)" onmouseover="showTip(event, 'fs17', 64)" class="t">Int32</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs18', 65)" onmouseover="showTip(event, 'fs18', 65)" class="i">MinValue</span> <span onmouseout="hideTip(event, 'fs17', 66)" onmouseover="showTip(event, 'fs17', 66)" class="t">Int32</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs19', 67)" onmouseover="showTip(event, 'fs19', 67)" class="i">MaxValue</span> <span class="c">// 2147483647</span>
</code></pre></td>
</tr>
</table>
<p>The identity element for string is just the empty string</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs16', 68)" onmouseover="showTip(event, 'fs16', 68)" class="f">max</span> <span class="s">&quot;&quot;</span> <span class="s">&quot;&quot;</span>    <span class="c">// &quot;&quot;</span>
<span onmouseout="hideTip(event, 'fs16', 69)" onmouseover="showTip(event, 'fs16', 69)" class="f">max</span> <span class="s">&quot;&quot;</span> <span class="s">&quot;Foo&quot;</span> <span class="c">// &quot;Foo&quot;</span>
<span onmouseout="hideTip(event, 'fs16', 70)" onmouseover="showTip(event, 'fs16', 70)" class="f">max</span> <span class="s">&quot;&quot;</span> <span class="s">&quot;Bar&quot;</span> <span class="c">// &quot;Bar&quot; </span>
<span onmouseout="hideTip(event, 'fs16', 71)" onmouseover="showTip(event, 'fs16', 71)" class="f">max</span> <span class="s">&quot;&quot;</span> <span class="s">&quot;Baz&quot;</span> <span class="c">// &quot;Baz&quot;</span>
</code></pre></td>
</tr>
</table>
<a name="mono-sets"></a>
<h3>Combining Sets</h3>
<p>Also combining two Sets is a monoid, once again with just the empty set as the identity element.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
<span class="l">7: </span>
<span class="l">8: </span>
<span class="l">9: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs20', 72)" onmouseover="showTip(event, 'fs20', 72)" class="i">sa</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs21', 73)" onmouseover="showTip(event, 'fs21', 73)" class="f">set</span> [<span class="n">1</span>;<span class="n">2</span>]
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs22', 74)" onmouseover="showTip(event, 'fs22', 74)" class="i">sb</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs21', 75)" onmouseover="showTip(event, 'fs21', 75)" class="f">set</span> [<span class="n">2</span>;<span class="n">3</span>]
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs23', 76)" onmouseover="showTip(event, 'fs23', 76)" class="i">sc</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs21', 77)" onmouseover="showTip(event, 'fs21', 77)" class="f">set</span> [<span class="n">3</span>;<span class="n">4</span>]

(<span onmouseout="hideTip(event, 'fs24', 78)" onmouseover="showTip(event, 'fs24', 78)" class="t">Set</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs25', 79)" onmouseover="showTip(event, 'fs25', 79)" class="f">union</span> (<span onmouseout="hideTip(event, 'fs24', 80)" onmouseover="showTip(event, 'fs24', 80)" class="t">Set</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs25', 81)" onmouseover="showTip(event, 'fs25', 81)" class="f">union</span> <span onmouseout="hideTip(event, 'fs20', 82)" onmouseover="showTip(event, 'fs20', 82)" class="i">sa</span> <span onmouseout="hideTip(event, 'fs22', 83)" onmouseover="showTip(event, 'fs22', 83)" class="i">sb</span>) <span onmouseout="hideTip(event, 'fs23', 84)" onmouseover="showTip(event, 'fs23', 84)" class="i">sc</span>) <span class="c">// set [1;2;3;4]</span>
(<span onmouseout="hideTip(event, 'fs24', 85)" onmouseover="showTip(event, 'fs24', 85)" class="t">Set</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs25', 86)" onmouseover="showTip(event, 'fs25', 86)" class="f">union</span> <span onmouseout="hideTip(event, 'fs20', 87)" onmouseover="showTip(event, 'fs20', 87)" class="i">sa</span> (<span onmouseout="hideTip(event, 'fs24', 88)" onmouseover="showTip(event, 'fs24', 88)" class="t">Set</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs25', 89)" onmouseover="showTip(event, 'fs25', 89)" class="f">union</span> <span onmouseout="hideTip(event, 'fs22', 90)" onmouseover="showTip(event, 'fs22', 90)" class="i">sb</span> <span onmouseout="hideTip(event, 'fs23', 91)" onmouseover="showTip(event, 'fs23', 91)" class="i">sc</span>)) <span class="c">// set [1;2;3;4]</span>

<span onmouseout="hideTip(event, 'fs7', 92)" onmouseover="showTip(event, 'fs7', 92)" class="t">List</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs14', 93)" onmouseover="showTip(event, 'fs14', 93)" class="f">fold</span> <span onmouseout="hideTip(event, 'fs24', 94)" onmouseover="showTip(event, 'fs24', 94)" class="t">Set</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs25', 95)" onmouseover="showTip(event, 'fs25', 95)" class="f">union</span> <span onmouseout="hideTip(event, 'fs24', 96)" onmouseover="showTip(event, 'fs24', 96)" class="t">Set</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs26', 97)" onmouseover="showTip(event, 'fs26', 97)" class="i">empty</span> [<span onmouseout="hideTip(event, 'fs20', 98)" onmouseover="showTip(event, 'fs20', 98)" class="i">sa</span>; <span onmouseout="hideTip(event, 'fs22', 99)" onmouseover="showTip(event, 'fs22', 99)" class="i">sb</span>; <span onmouseout="hideTip(event, 'fs23', 100)" onmouseover="showTip(event, 'fs23', 100)" class="i">sc</span>] <span class="c">// [1;2;3;4]</span>
<span onmouseout="hideTip(event, 'fs7', 101)" onmouseover="showTip(event, 'fs7', 101)" class="t">List</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs14', 102)" onmouseover="showTip(event, 'fs14', 102)" class="f">fold</span> <span onmouseout="hideTip(event, 'fs24', 103)" onmouseover="showTip(event, 'fs24', 103)" class="t">Set</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs25', 104)" onmouseover="showTip(event, 'fs25', 104)" class="f">union</span> <span onmouseout="hideTip(event, 'fs24', 105)" onmouseover="showTip(event, 'fs24', 105)" class="t">Set</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs26', 106)" onmouseover="showTip(event, 'fs26', 106)" class="i">empty</span> [<span onmouseout="hideTip(event, 'fs23', 107)" onmouseover="showTip(event, 'fs23', 107)" class="i">sc</span>; <span onmouseout="hideTip(event, 'fs22', 108)" onmouseover="showTip(event, 'fs22', 108)" class="i">sb</span>; <span onmouseout="hideTip(event, 'fs20', 109)" onmouseover="showTip(event, 'fs20', 109)" class="i">sa</span>] <span class="c">// [1;2;3;4]</span>
</code></pre></td>
</tr>
</table>
<a name="comm-monoids"></a>
<h2>Commutative Monoids</h2>
<p>Up so far you probably noticed one additional variation. For some combine operations
the whole order on how we combine them don't play a role. Actually <code>+</code> for
numbers and the <code>Set.union</code> fall into this category. But other operation are
<em>just</em> associative, for example List or String concatenation. When we concatenate
three strings, it doesn't matter if we do <code>(a + b) + c</code> or <code>a + (b + c)</code>. But
we cannot do <code>(a + c) + b</code>. This will give us a completely different string.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp">(<span class="s">&quot;foo&quot;</span> <span class="o">+</span> <span class="s">&quot;bar&quot;</span>) <span class="o">+</span> <span class="s">&quot;baz&quot;</span> <span class="c">// &quot;foobarbaz&quot;</span>
<span class="s">&quot;foo&quot;</span> <span class="o">+</span> (<span class="s">&quot;bar&quot;</span> <span class="o">+</span> <span class="s">&quot;baz&quot;</span>) <span class="c">// &quot;foobarbaz&quot;</span>
(<span class="s">&quot;foo&quot;</span> <span class="o">+</span> <span class="s">&quot;baz&quot;</span>) <span class="o">+</span> <span class="s">&quot;bar&quot;</span> <span class="c">// &quot;foobazbar&quot;</span>
</code></pre></td>
</tr>
</table>
<p>But for other operations, the whole order doesn't matter</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp">(<span class="n">1</span> <span class="o">+</span> <span class="n">2</span>) <span class="o">+</span> <span class="n">3</span> <span class="c">// 6</span>
<span class="n">1</span> <span class="o">+</span> (<span class="n">2</span> <span class="o">+</span> <span class="n">3</span>) <span class="c">// 6</span>
(<span class="n">1</span> <span class="o">+</span> <span class="n">3</span>) <span class="o">+</span> <span class="n">2</span> <span class="c">// 6</span>
</code></pre></td>
</tr>
</table>
<p>We can even shuffle an array before summing it, it will always give us the same sum.
But shuffling an array of strings, will return another string. When we have a monoid
where the whole order doesn't play a role. then we have a <em>Commutative Monoid</em>.</p>
<p>For example adding numbers or multiplying them, combining sets with <code>Set.union</code> or
getting the <code>max</code> value are <em>Commutative Monoids</em>.</p>
<a name="type"></a>
<h2>Creating Monoids Types</h2>
<p>Up so far we always used <code>List.fold</code> or <code>List.reduce</code> directly and provided the identity
element directly. But overall it can help to create a type that combines the binary
operation with the identity element in its own type.</p>
<p>We can overload the <code>+</code> and the <code>Zero</code> operator to get some nice behaviour. We treat
<code>+</code> just as our <em>combine</em> operation. And <code>Zero</code> is our <em>identity</em> element.</p>
<a name="type-sum"></a>
<h3>Sum Monoid</h3>
<p>As a simple example let's create a <code>Sum</code> type.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span onmouseout="hideTip(event, 'fs27', 110)" onmouseover="showTip(event, 'fs27', 110)" class="t">Sum</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs27', 111)" onmouseover="showTip(event, 'fs27', 111)" class="p">Sum</span> <span class="k">of</span> <span onmouseout="hideTip(event, 'fs28', 112)" onmouseover="showTip(event, 'fs28', 112)" class="t">int</span> <span class="k">with</span>
    <span class="k">static</span> <span class="k">member</span> (<span class="o">+</span>) (<span onmouseout="hideTip(event, 'fs27', 113)" onmouseover="showTip(event, 'fs27', 113)" class="p">Sum</span> <span onmouseout="hideTip(event, 'fs29', 114)" onmouseover="showTip(event, 'fs29', 114)" class="i">x</span>, <span onmouseout="hideTip(event, 'fs27', 115)" onmouseover="showTip(event, 'fs27', 115)" class="p">Sum</span> <span onmouseout="hideTip(event, 'fs30', 116)" onmouseover="showTip(event, 'fs30', 116)" class="i">y</span>) <span class="o">=</span> <span onmouseout="hideTip(event, 'fs27', 117)" onmouseover="showTip(event, 'fs27', 117)" class="p">Sum</span> (<span onmouseout="hideTip(event, 'fs29', 118)" onmouseover="showTip(event, 'fs29', 118)" class="i">x</span> <span class="o">+</span> <span onmouseout="hideTip(event, 'fs30', 119)" onmouseover="showTip(event, 'fs30', 119)" class="i">y</span>)
    <span class="k">static</span> <span class="k">member</span> <span onmouseout="hideTip(event, 'fs31', 120)" onmouseover="showTip(event, 'fs31', 120)" class="i">Zero</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs27', 121)" onmouseover="showTip(event, 'fs27', 121)" class="p">Sum</span> <span class="n">0</span>
</code></pre></td>
</tr>
</table>
<p>The advantage is that we can use <code>List.sum</code> with such a type. <code>List.sum</code> adds all elements
together with the <code>+</code> operator. So it is like <code>reduce</code>, but in the case of an empty list,
it returns the <code>Zero</code> element.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs7', 122)" onmouseover="showTip(event, 'fs7', 122)" class="t">List</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs32', 123)" onmouseover="showTip(event, 'fs32', 123)" class="f">sum</span> [<span onmouseout="hideTip(event, 'fs27', 124)" onmouseover="showTip(event, 'fs27', 124)" class="p">Sum</span> <span class="n">1</span>; <span onmouseout="hideTip(event, 'fs27', 125)" onmouseover="showTip(event, 'fs27', 125)" class="p">Sum</span> <span class="n">2</span>; <span onmouseout="hideTip(event, 'fs27', 126)" onmouseover="showTip(event, 'fs27', 126)" class="p">Sum</span> <span class="n">3</span>]  <span class="c">// Sum 6</span>
<span onmouseout="hideTip(event, 'fs7', 127)" onmouseover="showTip(event, 'fs7', 127)" class="t">List</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs32', 128)" onmouseover="showTip(event, 'fs32', 128)" class="f">sum</span> [<span onmouseout="hideTip(event, 'fs27', 129)" onmouseover="showTip(event, 'fs27', 129)" class="p">Sum</span> <span class="n">5</span>; <span onmouseout="hideTip(event, 'fs27', 130)" onmouseover="showTip(event, 'fs27', 130)" class="p">Sum</span> <span class="n">10</span>; <span onmouseout="hideTip(event, 'fs27', 131)" onmouseover="showTip(event, 'fs27', 131)" class="p">Sum</span> <span class="n">5</span>] <span class="c">// Sum 20</span>
</code></pre></td>
</tr>
</table>
<p>Defining a Sum type for <code>int</code> and <code>+</code> doesn't seems like much value, and it isn't. But it
is only one example to understand the concept. A Product for example seems much more usable.</p>
<a name="type-product"></a>
<h3>Product Monoid</h3>
<p>The product Monoid just multiplies the numbers and we use <code>1</code> as Zero.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span onmouseout="hideTip(event, 'fs33', 132)" onmouseover="showTip(event, 'fs33', 132)" class="t">Product</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs33', 133)" onmouseover="showTip(event, 'fs33', 133)" class="p">Product</span> <span class="k">of</span> <span onmouseout="hideTip(event, 'fs28', 134)" onmouseover="showTip(event, 'fs28', 134)" class="t">int</span> <span class="k">with</span>
    <span class="k">static</span> <span class="k">member</span> (<span class="o">+</span>) (<span onmouseout="hideTip(event, 'fs33', 135)" onmouseover="showTip(event, 'fs33', 135)" class="p">Product</span> <span onmouseout="hideTip(event, 'fs29', 136)" onmouseover="showTip(event, 'fs29', 136)" class="i">x</span>, <span onmouseout="hideTip(event, 'fs33', 137)" onmouseover="showTip(event, 'fs33', 137)" class="p">Product</span> <span onmouseout="hideTip(event, 'fs30', 138)" onmouseover="showTip(event, 'fs30', 138)" class="i">y</span>) <span class="o">=</span> <span onmouseout="hideTip(event, 'fs33', 139)" onmouseover="showTip(event, 'fs33', 139)" class="p">Product</span> (<span onmouseout="hideTip(event, 'fs29', 140)" onmouseover="showTip(event, 'fs29', 140)" class="i">x</span> <span class="o">*</span> <span onmouseout="hideTip(event, 'fs30', 141)" onmouseover="showTip(event, 'fs30', 141)" class="i">y</span>)
    <span class="k">static</span> <span class="k">member</span> <span onmouseout="hideTip(event, 'fs34', 142)" onmouseover="showTip(event, 'fs34', 142)" class="i">Zero</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs33', 143)" onmouseover="showTip(event, 'fs33', 143)" class="p">Product</span> <span class="n">1</span>

<span onmouseout="hideTip(event, 'fs7', 144)" onmouseover="showTip(event, 'fs7', 144)" class="t">List</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs32', 145)" onmouseover="showTip(event, 'fs32', 145)" class="f">sum</span> [<span onmouseout="hideTip(event, 'fs33', 146)" onmouseover="showTip(event, 'fs33', 146)" class="p">Product</span> <span class="n">5</span>; <span onmouseout="hideTip(event, 'fs33', 147)" onmouseover="showTip(event, 'fs33', 147)" class="p">Product</span> <span class="n">10</span>; <span onmouseout="hideTip(event, 'fs33', 148)" onmouseover="showTip(event, 'fs33', 148)" class="p">Product</span> <span class="n">3</span>] <span class="c">// Product 150</span>
<span onmouseout="hideTip(event, 'fs7', 149)" onmouseover="showTip(event, 'fs7', 149)" class="t">List</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs32', 150)" onmouseover="showTip(event, 'fs32', 150)" class="f">sum</span> [<span onmouseout="hideTip(event, 'fs33', 151)" onmouseover="showTip(event, 'fs33', 151)" class="p">Product</span> <span class="n">3</span>; <span onmouseout="hideTip(event, 'fs33', 152)" onmouseover="showTip(event, 'fs33', 152)" class="p">Product</span> <span class="n">2</span>]             <span class="c">// Product 6</span>
</code></pre></td>
</tr>
</table>
<a name="type-ordering"></a>
<h3>Ordering Monoid</h3>
<p>Let's create a Monoid that adds two list together and sorts the list while doing it.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
<span class="l">7: </span>
<span class="l">8: </span>
<span class="l">9: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span onmouseout="hideTip(event, 'fs35', 153)" onmouseover="showTip(event, 'fs35', 153)" class="t">Order</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">a</span> <span class="k">when</span> <span class="o">&#39;</span><span class="i">a</span> <span class="o">:</span> <span class="i">comparison</span><span class="o">&gt;</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs35', 154)" onmouseover="showTip(event, 'fs35', 154)" class="p">Order</span> <span class="k">of</span> <span class="o">&#39;</span><span class="i">a</span> <span onmouseout="hideTip(event, 'fs36', 155)" onmouseover="showTip(event, 'fs36', 155)" class="t">list</span> <span class="k">with</span>
    <span class="k">static</span> <span class="k">member</span> (<span class="o">+</span>) (<span onmouseout="hideTip(event, 'fs35', 156)" onmouseover="showTip(event, 'fs35', 156)" class="p">Order</span> <span onmouseout="hideTip(event, 'fs37', 157)" onmouseover="showTip(event, 'fs37', 157)" class="i">xs</span> <span class="o">:</span> <span onmouseout="hideTip(event, 'fs35', 158)" onmouseover="showTip(event, 'fs35', 158)" class="t">Order</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">a</span><span class="o">&gt;</span>, <span onmouseout="hideTip(event, 'fs35', 159)" onmouseover="showTip(event, 'fs35', 159)" class="p">Order</span> <span onmouseout="hideTip(event, 'fs38', 160)" onmouseover="showTip(event, 'fs38', 160)" class="i">ys</span>) <span class="o">=</span> <span onmouseout="hideTip(event, 'fs35', 161)" onmouseover="showTip(event, 'fs35', 161)" class="p">Order</span> (<span onmouseout="hideTip(event, 'fs7', 162)" onmouseover="showTip(event, 'fs7', 162)" class="t">List</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs39', 163)" onmouseover="showTip(event, 'fs39', 163)" class="f">sort</span> (<span onmouseout="hideTip(event, 'fs7', 164)" onmouseover="showTip(event, 'fs7', 164)" class="t">List</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs15', 165)" onmouseover="showTip(event, 'fs15', 165)" class="f">append</span> <span onmouseout="hideTip(event, 'fs6', 166)" onmouseover="showTip(event, 'fs6', 166)" class="i">xs</span> <span class="i">ys</span>))
    <span class="k">static</span> <span class="k">member</span> <span onmouseout="hideTip(event, 'fs40', 167)" onmouseover="showTip(event, 'fs40', 167)" class="i">Zero</span> <span class="o">:</span> <span onmouseout="hideTip(event, 'fs35', 168)" onmouseover="showTip(event, 'fs35', 168)" class="t">Order</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">a</span><span class="o">&gt;</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs35', 169)" onmouseover="showTip(event, 'fs35', 169)" class="p">Order</span> []

<span onmouseout="hideTip(event, 'fs35', 170)" onmouseover="showTip(event, 'fs35', 170)" class="p">Order</span> [<span class="n">3</span>;<span class="n">4</span>] <span class="o">+</span> <span onmouseout="hideTip(event, 'fs35', 171)" onmouseover="showTip(event, 'fs35', 171)" class="p">Order</span> [<span class="n">1</span>;<span class="n">2</span>] <span class="o">+</span> <span onmouseout="hideTip(event, 'fs35', 172)" onmouseover="showTip(event, 'fs35', 172)" class="p">Order</span> [<span class="n">6</span>;<span class="n">6</span>;<span class="n">10</span>] <span class="c">// [1;2;3;4;6;6;10]</span>
<span onmouseout="hideTip(event, 'fs35', 173)" onmouseover="showTip(event, 'fs35', 173)" class="p">Order</span> [<span class="s">&quot;foo&quot;</span>;<span class="s">&quot;bar&quot;</span>] <span class="o">+</span> <span onmouseout="hideTip(event, 'fs35', 174)" onmouseover="showTip(event, 'fs35', 174)" class="p">Order</span> [<span class="s">&quot;zoo&quot;</span>]        <span class="c">// [&quot;bar&quot;; &quot;foo&quot;; &quot;zoo&quot;]</span>

<span onmouseout="hideTip(event, 'fs7', 175)" onmouseover="showTip(event, 'fs7', 175)" class="t">List</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs32', 176)" onmouseover="showTip(event, 'fs32', 176)" class="f">sum</span> [<span onmouseout="hideTip(event, 'fs35', 177)" onmouseover="showTip(event, 'fs35', 177)" class="p">Order</span> [<span class="n">3</span>;<span class="n">4</span>]; <span onmouseout="hideTip(event, 'fs35', 178)" onmouseover="showTip(event, 'fs35', 178)" class="p">Order</span> [<span class="n">1</span>;<span class="n">2</span>]]           <span class="c">// [1;2;3;4]</span>
<span onmouseout="hideTip(event, 'fs7', 179)" onmouseover="showTip(event, 'fs7', 179)" class="t">List</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs32', 180)" onmouseover="showTip(event, 'fs32', 180)" class="f">sum</span> [<span onmouseout="hideTip(event, 'fs35', 181)" onmouseover="showTip(event, 'fs35', 181)" class="p">Order</span> [<span class="s">&quot;foo&quot;</span>;<span class="s">&quot;bar&quot;</span>]; <span onmouseout="hideTip(event, 'fs35', 182)" onmouseover="showTip(event, 'fs35', 182)" class="p">Order</span> [<span class="s">&quot;zoo&quot;</span>]] <span class="c">// [&quot;bar&quot;; &quot;foo&quot;; &quot;zoo&quot;]</span>
</code></pre></td>
</tr>
</table>
<a name="summary"></a>
<h2>Summary</h2>
<p>A Monoid is a simple way to aggregate data. When you design functions consider if there exists
binary operations to somehow combine types. If you can implement them you get the ability
to combine a list of types for free.</p>
<p>Additionally it opens up the possibility to allow combining data in parallel or build data
incrementally.</p>
<a name="further"></a>
<h2>Further Reading</h2>
<ul>
<li><a href="https://fsharpforfunandprofit.com/posts/monoids-without-tears/">Monoid without Tears</a></li>
<li><a href="http://gettingsharper.de/2015/03/03/understanding-monoids-using-f/">Understanding Monoids using F#</a></li>
<li><a href="http://learnyouahaskell.com/functors-applicative-functors-and-monoids#monoids">[Haskell] Learn You a Haskell</a></li>
<li><a href="https://en.wikibooks.org/wiki/Haskell/Monoids">[Haskell] Monoids</a></li>
</ul>
<a name="comments"></a>


<div class="tip" id="fs1">module Main</div>
<div class="tip" id="fs2">namespace System</div>
<div class="tip" id="fs3">Multiple items<br />namespace FSharp<br /><br />--------------------<br />namespace Microsoft.FSharp</div>
<div class="tip" id="fs4">Multiple items<br />namespace FSharp.Collections<br /><br />--------------------<br />namespace Microsoft.FSharp.Collections</div>
<div class="tip" id="fs5">namespace FSharp.Collections.ParallelSeq</div>
<div class="tip" id="fs6">val xs : float list<br /><br />Full name: Main.xs</div>
<div class="tip" id="fs7">Multiple items<br />module List<br /><br />from Microsoft.FSharp.Collections<br /><br />--------------------<br />type List&lt;&#39;T&gt; =<br />&#160;&#160;| ( [] )<br />&#160;&#160;| ( :: ) of Head: &#39;T * Tail: &#39;T list<br />&#160;&#160;interface IEnumerable<br />&#160;&#160;interface IEnumerable&lt;&#39;T&gt;<br />&#160;&#160;member GetSlice : startIndex:int option * endIndex:int option -&gt; &#39;T list<br />&#160;&#160;member Head : &#39;T<br />&#160;&#160;member IsEmpty : bool<br />&#160;&#160;member Item : index:int -&gt; &#39;T with get<br />&#160;&#160;member Length : int<br />&#160;&#160;member Tail : &#39;T list<br />&#160;&#160;static member Cons : head:&#39;T * tail:&#39;T list -&gt; &#39;T list<br />&#160;&#160;static member Empty : &#39;T list<br /><br />Full name: Microsoft.FSharp.Collections.List&lt;_&gt;</div>
<div class="tip" id="fs8">val reduce : reduction:(&#39;T -&gt; &#39;T -&gt; &#39;T) -&gt; list:&#39;T list -&gt; &#39;T<br /><br />Full name: Microsoft.FSharp.Collections.List.reduce</div>
<div class="tip" id="fs9">val nums : int64 []<br /><br />Full name: Main.nums</div>
<div class="tip" id="fs10">module Seq<br /><br />from Microsoft.FSharp.Collections</div>
<div class="tip" id="fs11">val reduce : reduction:(&#39;T -&gt; &#39;T -&gt; &#39;T) -&gt; source:seq&lt;&#39;T&gt; -&gt; &#39;T<br /><br />Full name: Microsoft.FSharp.Collections.Seq.reduce</div>
<div class="tip" id="fs12">module PSeq<br /><br />from FSharp.Collections.ParallelSeq</div>
<div class="tip" id="fs13">val reduce : reduction:(&#39;T -&gt; &#39;T -&gt; &#39;T) -&gt; source:seq&lt;&#39;T&gt; -&gt; &#39;T<br /><br />Full name: FSharp.Collections.ParallelSeq.PSeq.reduce</div>
<div class="tip" id="fs14">val fold : folder:(&#39;State -&gt; &#39;T -&gt; &#39;State) -&gt; state:&#39;State -&gt; list:&#39;T list -&gt; &#39;State<br /><br />Full name: Microsoft.FSharp.Collections.List.fold</div>
<div class="tip" id="fs15">val append : list1:&#39;T list -&gt; list2:&#39;T list -&gt; &#39;T list<br /><br />Full name: Microsoft.FSharp.Collections.List.append</div>
<div class="tip" id="fs16">val max : e1:&#39;T -&gt; e2:&#39;T -&gt; &#39;T (requires comparison)<br /><br />Full name: Microsoft.FSharp.Core.Operators.max</div>
<div class="tip" id="fs17">type Int32 =<br />&#160;&#160;struct<br />&#160;&#160;&#160;&#160;member CompareTo : value:obj -&gt; int + 1 overload<br />&#160;&#160;&#160;&#160;member Equals : obj:obj -&gt; bool + 1 overload<br />&#160;&#160;&#160;&#160;member GetHashCode : unit -&gt; int<br />&#160;&#160;&#160;&#160;member GetTypeCode : unit -&gt; TypeCode<br />&#160;&#160;&#160;&#160;member ToString : unit -&gt; string + 3 overloads<br />&#160;&#160;&#160;&#160;static val MaxValue : int<br />&#160;&#160;&#160;&#160;static val MinValue : int<br />&#160;&#160;&#160;&#160;static member Parse : s:string -&gt; int + 3 overloads<br />&#160;&#160;&#160;&#160;static member TryParse : s:string * result:int -&gt; bool + 1 overload<br />&#160;&#160;end<br /><br />Full name: System.Int32</div>
<div class="tip" id="fs18">field int.MinValue = -2147483648</div>
<div class="tip" id="fs19">field int.MaxValue = 2147483647</div>
<div class="tip" id="fs20">val sa : Set&lt;int&gt;<br /><br />Full name: Main.sa</div>
<div class="tip" id="fs21">val set : elements:seq&lt;&#39;T&gt; -&gt; Set&lt;&#39;T&gt; (requires comparison)<br /><br />Full name: Microsoft.FSharp.Core.ExtraTopLevelOperators.set</div>
<div class="tip" id="fs22">val sb : Set&lt;int&gt;<br /><br />Full name: Main.sb</div>
<div class="tip" id="fs23">val sc : Set&lt;int&gt;<br /><br />Full name: Main.sc</div>
<div class="tip" id="fs24">Multiple items<br />module Set<br /><br />from Microsoft.FSharp.Collections<br /><br />--------------------<br />type Set&lt;&#39;T (requires comparison)&gt; =<br />&#160;&#160;interface IComparable<br />&#160;&#160;interface IEnumerable<br />&#160;&#160;interface IEnumerable&lt;&#39;T&gt;<br />&#160;&#160;interface ICollection&lt;&#39;T&gt;<br />&#160;&#160;new : elements:seq&lt;&#39;T&gt; -&gt; Set&lt;&#39;T&gt;<br />&#160;&#160;member Add : value:&#39;T -&gt; Set&lt;&#39;T&gt;<br />&#160;&#160;member Contains : value:&#39;T -&gt; bool<br />&#160;&#160;override Equals : obj -&gt; bool<br />&#160;&#160;member IsProperSubsetOf : otherSet:Set&lt;&#39;T&gt; -&gt; bool<br />&#160;&#160;member IsProperSupersetOf : otherSet:Set&lt;&#39;T&gt; -&gt; bool<br />&#160;&#160;...<br /><br />Full name: Microsoft.FSharp.Collections.Set&lt;_&gt;<br /><br />--------------------<br />new : elements:seq&lt;&#39;T&gt; -&gt; Set&lt;&#39;T&gt;</div>
<div class="tip" id="fs25">val union : set1:Set&lt;&#39;T&gt; -&gt; set2:Set&lt;&#39;T&gt; -&gt; Set&lt;&#39;T&gt; (requires comparison)<br /><br />Full name: Microsoft.FSharp.Collections.Set.union</div>
<div class="tip" id="fs26">val empty&lt;&#39;T (requires comparison)&gt; : Set&lt;&#39;T&gt; (requires comparison)<br /><br />Full name: Microsoft.FSharp.Collections.Set.empty</div>
<div class="tip" id="fs27">Multiple items<br />union case Sum.Sum: int -&gt; Sum<br /><br />--------------------<br />type Sum =<br />&#160;&#160;| Sum of int<br />&#160;&#160;static member Zero : Sum<br />&#160;&#160;static member ( + ) : Sum * Sum -&gt; Sum<br /><br />Full name: Main.Sum</div>
<div class="tip" id="fs28">Multiple items<br />val int : value:&#39;T -&gt; int (requires member op_Explicit)<br /><br />Full name: Microsoft.FSharp.Core.Operators.int<br /><br />--------------------<br />type int = int32<br /><br />Full name: Microsoft.FSharp.Core.int<br /><br />--------------------<br />type int&lt;&#39;Measure&gt; = int<br /><br />Full name: Microsoft.FSharp.Core.int&lt;_&gt;</div>
<div class="tip" id="fs29">val x : int</div>
<div class="tip" id="fs30">val y : int</div>
<div class="tip" id="fs31">static member Sum.Zero : Sum<br /><br />Full name: Main.Sum.Zero</div>
<div class="tip" id="fs32">val sum : list:&#39;T list -&gt; &#39;T (requires member ( + ) and member get_Zero)<br /><br />Full name: Microsoft.FSharp.Collections.List.sum</div>
<div class="tip" id="fs33">Multiple items<br />union case Product.Product: int -&gt; Product<br /><br />--------------------<br />type Product =<br />&#160;&#160;| Product of int<br />&#160;&#160;static member Zero : Product<br />&#160;&#160;static member ( + ) : Product * Product -&gt; Product<br /><br />Full name: Main.Product</div>
<div class="tip" id="fs34">static member Product.Zero : Product<br /><br />Full name: Main.Product.Zero</div>
<div class="tip" id="fs35">Multiple items<br />union case Order.Order: &#39;a list -&gt; Order&lt;&#39;a&gt;<br /><br />--------------------<br />type Order&lt;&#39;a (requires comparison)&gt; =<br />&#160;&#160;| Order of &#39;a list<br />&#160;&#160;static member Zero : Order&lt;&#39;a&gt;<br />&#160;&#160;static member ( + ) : Order&lt;&#39;a&gt; * Order&lt;&#39;a&gt; -&gt; Order&lt;&#39;a&gt;<br /><br />Full name: Main.Order&lt;_&gt;</div>
<div class="tip" id="fs36">type &#39;T list = List&lt;&#39;T&gt;<br /><br />Full name: Microsoft.FSharp.Collections.list&lt;_&gt;</div>
<div class="tip" id="fs37">val xs : &#39;a list (requires comparison)</div>
<div class="tip" id="fs38">val ys : &#39;a list (requires comparison)</div>
<div class="tip" id="fs39">val sort : list:&#39;T list -&gt; &#39;T list (requires comparison)<br /><br />Full name: Microsoft.FSharp.Collections.List.sort</div>
<div class="tip" id="fs40">static member Order.Zero : Order&lt;&#39;a&gt;<br /><br />Full name: Main.Order`1.Zero</div>
